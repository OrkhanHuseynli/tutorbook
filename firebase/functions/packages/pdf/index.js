const Utils = require('utils');
const PDFDocument = require('pdfkit');
const PDFDocumentWithTables = require('./pdfkit-with-tables.js');
const cors = require('cors')({
    origin: true,
});
const styles = require('./styles.js');
const admin = require('firebase-admin');
const firestore = admin.firestore();
const partitions = {
    test: firestore.collection('partitions').doc('test'),
    default: firestore.collection('partitions').doc('default'),
};

const caps = (str) => {
    if (!str || typeof str !== 'string') return 'Unknown';
    if (str.substr(0, 4) === 'http') return str;
    return str[0].toUpperCase() + str.substr(1);
};

const parse = (key, val) => {
    switch (key) {
        case 'subjects':
            return (val.join(', ') || 'No subjects') + '.';
        case 'proxy':
            return (val.join(', ') || 'No proxies') + '.';
        case 'locations':
            return (val.join(', ') || 'No locations') + '.';
        case 'availability':
            return (Utils.getAvailabilityStrings(val).join(', ') || 'No ' +
                'availability') + '.';
        default:
            return 'Adding complex object-to-string conversion soon.';
    }
};

const enumerate = (ob, add, doc) => {
    Object.entries(ob).forEach(([key, val]) => {
        switch (typeof val) {
            case 'string':
                add(key + ': ', styles.bold, doc);
                add(val, styles.para, doc);
                break;
            case 'number':
                return doc
                add(key + ': ', styles.bold, doc);
                add(new String(val), styles.para, doc);
                break;
            case 'boolean':
                add(key + ': ', styles.bold, doc);
                add(val ? 'Yes' : 'No', styles.para, doc);
                break;
            case 'object':
                add(key + ': ', styles.bold, doc);
                add(parse(key, val), styles.para, doc);
                break;
            default:
                throw new Error('Unsupported field type: ' + typeof val);
        }
    });
};

const appts = async (ref, doc) => {
    const tutor = (appt) => (appt.attendees[0].type === 'Tutor') ? appt
        .attendees[0].name : appt.attendees[1].name;
    const pupil = (appt) => (appt.attendees[0].type === 'Pupil') ? appt
        .attendees[0].name : appt.attendees[1].name;
    const appts = (await ref.collection('appointments').get()).docs;
    if (appts.length === 0) return;
    add('Weekly Appointments', styles.h3, doc);
    appts.forEach((apptDoc) => {
        const appt = apptDoc.data();
        add(appt.time.day + 's - ' + appt.for.subject + ': ', styles.bold, doc);
        add('Weekly appointment between ' + tutor(appt) + ' (the tutor) and ' +
            pupil(appt) + ' (the pupil) at the ' + appt.location.name +
            ' from ' + appt.time.from + ' until ' + appt.time.to + '.',
            styles.para, doc);
    }); // TODO: Add pastAppointments as well (make limit configurable in req).
};

const add = (text, style, doc) => {
    if (style.font) doc.font(style.font);
    if (style.fontSize) doc.fontSize(style.fontSize);
    if (style.textTransform === 'capitalize') text = caps(text);
    if (style.textTransform === 'uppercase') text = text.toUpperCase();
    doc.text(text, style);
    if (style.padding && !style.continued) doc.y += style.padding;
};

/*
 *Export user data as a PDF.
 *@param {bool} tutors - Whether or not to include tutors data in PDF.
 *@param {bool} pupils - Whether or not to include pupils data in PDF.
 *@param {bool} test - Whether to use the test partition of our Firestore db.
 *@param {string} token - Valid supervisor auth token generated by Firebase.
 *@param {string} location - ID of location to export data for.
 *@returns {stream} pdf - Generated PDF piped as a stream into exp Response().
 */
const backupAsPDF = (req, res) => {
    return cors(req, res, async () => {
        const isTest = req.query.test === 'true';
        console.log('[INFO] Responding to ' + (isTest ? 'test' : 'live') +
            ' backup as PDF request for location (' + req.query.location +
            ')...');
        const token = await admin.auth().verifyIdToken(req.query.token);
        if (!token.supervisor) return res.status(400).send('[ERROR] Given ' +
            'authentication token lacks supervisor custom auth.');
        if (token.locations.indexOf(req.query.location) < 0) return res
            .status(400).send('[ERROR] Token\'s locations did not contain ' +
                'requested location.');
        const db = isTest ? partitions.test : partitions.default;
        const locations = (await db.collection('locations').get()).docs;
        if (locations.map(d => d.id).indexOf(req.query.location) < 0) return res
            .status(400).send('[ERROR] Requested location doesn\'t exist.');
        if (req.query.tutors !== 'true' && req.query.pupils !== 'true')
            return res.status(400).send('[ERROR] Skipping empty request.');
        const doc = new PDFDocument();
        const locationName = locations[locations
            .findIndex(d => d.id === req.query.location)].data().name;
        const types = req.query.tutors === 'true' &&
            req.query.pupils === 'true' ? ['Tutor', 'Pupil'] :
            req.query.tutors === 'true' ? ['Tutor'] : ['Pupil'];
        Object.values(styles).forEach((style) => {
            doc.registerFont(style.font, 'fonts/' + style.font + '.ttf');
        });
        doc.pipe(res);
        doc.image('img/text-logo-bg.png', 612 / 8, 792 / 3, {
            width: 612 * 3 / 4, // Center horz, 1/3 from top, and size 3/4 width
        });
        doc.y += (792 / 3) + styles.h1.padding;
        add(locationName.split(' ')[0] + ' Data Backup', styles.h1, doc);
        for (d of (await db
                .collection('users')
                .where('location', '==', locationName)
                .where('type', 'in', types)
                .orderBy('name')
                .get()
            ).docs) {
            var user = d.data();
            doc.addPage();
            add(user.name, styles.h2, doc);
            enumerate(user, add, doc);
            await appts(d.ref, doc);
        }
        doc.end();
    });
};

const addUserServiceHours = async (d, doc, isTest) => {
    console.log('[DEBUG] Adding ' + d.data().name + ' (' + d.id + ')\'s ' +
        (isTest ? 'test' : 'live') + ' service hour data to PDF...');
    const db = isTest ? partitions.test : partitions.default;
    const appts = (await d.ref.collection('pastAppointments')
        .orderBy('clockIn.sentTimestamp').get()).docs;
    if (!appts.length) return console.warn('[WARNING] Did not fetch any ' +
        'pastAppts, skipping ' + d.data().name + ' (' + d.id + ')...');
    const table = {
        headers: [
            'Date',
            'Clock-in',
            'Pupil name',
            'Subject',
            'Clock-out',
            'Duration',
            'Initials',
            'Verification',
            'Total',
        ],
        cols: [
            0.08, // Date
            0.10, // Clock-in time
            0.16, // Pupil name
            0.17, // Subject
            0.10, // Clock-out time
            0.10, // Duration
            0.08, // Pupil initials
            0.11, // Supervisor initials
            0.10, // Running total
        ],
        rows: [],
    };
    const pop = (arr) => {
        arr.pop();
        return arr;
    };
    var a, cIn, cInSplit, cOut, cOutSplit,
        supervisor, duration, runningTotal = '00:00:00';
    for (appt of appts) {
        a = appt.data();
        cIn = a.clockIn.sentTimestamp.toDate();
        cInSplit = cIn.toLocaleString('en-US').split(', ');
        cOut = a.clockOut.sentTimestamp.toDate();
        cOutSplit = cOut.toLocaleString('en-US').split(', ');
        supervisor = (await db.collection('users').doc(a.supervisor)
            .get()).data();
        duration = Utils.getDurationStringFromDates(cIn, cOut);
        runningTotal = Utils.addDurationStrings(runningTotal, duration);
        table.rows.push([
            pop(cInSplit[0].split('/')).join('/'),
            pop(cInSplit[1].split(' ')[0].split(':')).join(':') + ' ' + cIn
            .toLocaleString('en-US').split(' ')[2],
            a.for.fromUser.name,
            a.for.subject,
            pop(cOutSplit[1].split(' ')[0].split(':')).join(':') + ' ' + cOut
            .toLocaleString('en-US').split(' ')[2],
            duration,
            a.for.fromUser.name.split(' ').map(n => n[0]).join('.') + '.',
            supervisor.name.split(' ').map(n => n[0]).join('.') + '.',
            runningTotal,
        ]);
    }
    doc.addPage({
        margin: 24,
    });
    add(d.data().name, styles.h2, doc);
    doc.table(table, {
        prepareHeader: () => doc.font(styles.bold.font)
            .fontSize(styles.bold.fontSize - 2),
        prepareRow: (row, i) => doc.font(styles.para.font)
            .fontSize(styles.para.fontSize - 2),
        columnSpacing: 10,
    });
};

/*
 *Export service hours PDF for groups of or a certain user.
 *@param {string} uid - The Firebase user ID of who you want to export data for.
 *@param {string} location - Location ID to export user data from (ignored if a 
 *valid uid was given).
 *@param {bool} test - Whether to use the test partition of our Firestore db.
 *@param {string} token - Valid supervisor auth token generated by Firebase.
 *@return {stream} pdf - User service hours in PDF form piped to exp Response().
 */
const serviceHoursAsPDF = (req, res) => {
    return cors(req, res, async () => {
        const isTest = req.query.test === 'true';
        console.log('[INFO] Responding to ' + (isTest ? 'test' : 'live') +
            ' service hours as PDF request for location (' +
            req.query.location + ') and user ID (' + req.query.uid + ')...');
        const token = await admin.auth().verifyIdToken(req.query.token);
        if (!token.supervisor) return res.status(400).send('[ERROR] Given ' +
            'authentication token lacks supervisor custom auth.');
        const db = isTest ? partitions.test : partitions.default;
        const doc = new PDFDocumentWithTables({
            autoFirstPage: false,
        });
        doc.pipe(res);
        Object.values(styles).forEach((style) => {
            doc.registerFont(style.font, 'fonts/' + style.font + '.ttf');
        });
        if (req.query.uid) {
            const user = await db.collection('users').doc(req.query.uid).get();
            if (!user.exists) return res.status(400).send('[ERROR] Requested ' +
                'user (' + req.query.uid + ') did not exist.');
            await addUserServiceHours(user, doc, isTest);
        } else if (req.query.location) {
            doc.addPage();
            doc.image('img/text-logo-bg.png', 612 / 8, 792 / 3, {
                width: 612 * 3 / 4,
            });
            doc.y += (792 / 3) + styles.h1.padding;
            add(locationName.split(' ')[0] + ' Service Hours', styles.h1, doc);
            if (token.locations.indexOf(req.query.location) < 0) return res
                .status(400).send('[ERROR] Token\'s locations did not contain' +
                    ' requested location.');
            const locations = (await db.collection('locations').get()).docs;
            if (locations.map(d => d.id).indexOf(req.query.location) < 0)
                return res.status(400).send('[ERROR] Requested location doesn' +
                    '\'t exist.');
            const locationName = locations[locations
                .findIndex(d => d.id === req.query.location)].data().name;
            const users = (await db.collection('users')
                .where('location', '==', locationName)
                .orderBy('name')
                .get()
            ).docs;
            for (user of users) {
                await addUserServiceHours(user, doc, isTest);
            }
        } else {
            return res.status(400).send('[ERROR] Request did not send a valid' +
                ' location ID or user ID to export service hours for.');
        }
        return doc.end();
    });
};

module.exports = {
    backup: backupAsPDF,
    hrs: serviceHoursAsPDF,
};